---
title: "R for Data Science Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

# Data Visualization with ggplot2
1.1 INTRODUCTION Plot fuel efficiency on highway against the car's engine size
```{r}
library(tidyverse)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
```

1.2 AESTHETIC MAPPING Add aesthetic property to car's class

```{r}
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

Set aesthetic properties of the geom manually - color outside aesthetics, don't convey info about variables

```{r}
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy), color = "blue"
)
```

1.3 FACETS Split your plot into facets, subplots that each display one subset of the data.

```{r}
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ cyl)

ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(. ~ cyl)
```

1.4 GEOMETRIC OBJECTS Change geom in ggplot2 syntax and map aesthetic to a discrete variable to draw multiple objects.

```{r}
ggplot(data = mpg) +
geom_smooth(mapping = aes(x = displ, y = hwy)) 

ggplot(data = mpg) +
geom_smooth(mapping = aes(x = displ, y = hwy, color = drv),
show.legend = FALSE)
```
Display multiple geoms in the same plot, passing the mapping to ggplot().
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
geom_point() +
geom_smooth()
```
Local data argument in a geom function overwrites the global mappings for that layer only.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
geom_point(mapping = aes(color = class)) +
geom_smooth(
data = filter(mpg, class == "subcompact"),
se = FALSE
)

```
1.5 STATISTICAL TRANSFORMATIONS interchangeable bar chart plot and stat count for diamonds.
*This works because every geom has a default stat, and every stat has a default geom.*

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
ggplot(data = diamonds) +
stat_count(mapping = aes(x = cut))

```
1.6 POSITION ADJUSTMENTS add color aesthetics to bar charts - map fill aesthetic to another variable, bars are automatically stacked
*question - what does "position" and "identity" truly mean? and why would overlap occur? pp. 28*
position = "identity" will place each object exactly where it falls in the context of the graph. This is not very useful for bars, because it overlaps them. To see that overlapping we either need to make the bars slightly transparent by setting alpha to a small value, or completely transparent by setting fill = NA:
```{r}
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity))
 
ggplot(
data = diamonds,
mapping = aes(x = cut, fill = clarity)
) +
geom_bar(alpha = 1/5, position = "identity")
ggplot(
data = diamonds,
mapping = aes(x = cut, color = clarity)
) +
geom_bar(fill = NA, position = "identity")

ggplot(
data = diamonds,
mapping = aes(x = cut, fill = clarity)
) +
geom_bar(position = "identity")
```
Position = “fill" is used for comparing proportion values; Position = "dodge" is used for comparing individual values
```{r}
ggplot(data = diamonds) +
geom_bar(
mapping = aes(x = cut, fill = clarity),
position = "fill"
)

ggplot(data = diamonds) +
geom_bar(
mapping = aes(x = cut, fill = clarity),
position = "dodge"
)
```
Add random noise to the plot to reveal spreads of data points using Position = "jitter"

```{r}
ggplot(data = mpg) +
geom_point(
mapping = aes(x = displ, y = hwy),
position = "jitter"
)
```
1.7 COORDINATE SYSTEM
The default coordinate system is the Cartesian coordinate system where the x and y position act independently to find the location of each point.

coord_flip () switches x and y position to avoid overlapping on x-axes.

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
geom_boxplot() +
coord_flip()
```
coord_polar() uses polar coordinates. Polar coordinates reveal an interesting connection between a bar chart and a Coxcomb
chart

```{r}
bar <- ggplot(data = diamonds) +
geom_bar(
mapping = aes(x = cut, fill = clarity),

) +
theme(aspect.ratio = 1) +
labs(x = NULL, y = NULL)
bar + coord_flip()
bar + coord_polar()
```
# Data Transformation with dplyr
```{r}
install.packages("nycflights13")
library(nycflights13)
library(tidyverse)
?flights
flights
```

3.1 Variable Type:
• int stands for integers.
• dbl stands for doubles, or real numbers.
• chr stands for character vectors, or strings.
• dttm stands for date-times (a date + a time).
• lgl stands for logical, vectors that contain only TRUE or FALSE.
• fctr stands for factors, which R uses to represent categorical
variables with fixed possible values.
• date stands for dates.

3.2 dplyr Basics:
Language of Data Manipulation:
• Pick observations by their values (filter()).
• Reorder the rows (arrange()).
• Pick variables by their names (select()).
• Create new variables with functions of existing variables
(mutate()).
• Collapse many values down to a single summary (summa
rize()).
• group_by(), which changes the scope of each function from operating on the entire dataset to operating on it group-by-group.

3.3 Filter Rows with filter()
dplyr executes the filtering operation and returns a new data frame.

```{r}
filter(flights, month == 1, day == 1)
```

if you want to save the result, you’ll need to use the assignment operator, <-:

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

If you want to do both, you can wrap the assignment in parentheses:

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

Comparisons and Boolean operators:
1. R provides the standard suite: >, >=, <, <=, != (not equal), and == (equal).
2. & is “and,” | is “or,” and ! is “not.”
3. De Morgan’s law: !(x & y) is the same as !x | !y, and !(x | y) is the same as !x & !y.
Example:

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```
4. Problem with month = 11|12 -> becomes month = 1. A useful shorthand for this problem is x %in% y.
```{r}
(nov_dec <- filter(flights, month %in% c(11, 12)))
```
Missing Values:
NA represents an unknown value so missing values are “contagious”; almost any operation involving an unknown value will also be unknown
Need to manually include NA values in filtering:
```{r}
(df <- tibble(x = c(1, NA, 3)))
```

3.4 Arrange Rows with arrange()
1. Missing values are always sorted at the end:
2. It takes a data frame and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns
3. Use desc() to reorder by a column in descending order

How to sort all missing values to the start? use is.na()
```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)))

```
3.5 Select Columns with select()

```{r}
# Select all columns between year and day (inclusive)
select(flights, year:day)
# Select all columns except those from year to day (inclusive)
select(flights, -(year:day))
```

There are a number of helper functions you can use within select():
• starts_with("abc") matches names that begin with “abc”.
• ends_with("xyz") matches names that end with “xyz”.
• contains("ijk") matches names that contain “ijk”.
• matches("(.)\\1") selects variables that match a regular expression. This one matches any variables that contain repeated characters. You’ll learn more about regular expressions
in Chapter 11.
*what is (.)\\1?*
• num_range("x", 1:3) matches x1, x2, and x3.

use rename(), which is a variant of select() that keeps all the variables that aren’t explicitly mentioned

```{r}
rename(flights, tail_num = tailnum)
```
Another option is to use select() in conjunction with the every thing() helper. This is useful if you have a handful of variables you’d like to move to the start of the data frame

```{r}
select(flights, time_hour, air_time, everything())
```
3.6 Add New Variables With mutate(); mutate adds new variables to the end of the dataset; if only wants to keep new variables created, use transmute
```{r}
flights_sml <- select(flights,
year:day,
ends_with("delay"),
distance,
air_time
)
mutate(flights_sml,
gain = arr_delay - dep_delay,
speed = distance / air_time * 60)

transmute(flights,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours
)
```

#Useful Creation Functions
1. Arithmetic operations - +,-,*,/,^
2. Modeular arithmetic (%/% integer division; %% remainder)
3. Logs log(), log2(), log10(). - I recommend using log2() because it’s easy to interpret: a difference of 1 on the log scale corresponds to doubling on the original scale and a difference of –1 corresponds to halving.
4. *offsets lag() and lead()* not sure what this means? 
5. Cumulative and running means - R provides functions for running sums, products, mins, and maxes: cumsum(), cumprod(), cummin(), cummax(); and dplyr provides cummean() for cumulative means.
6. Logical comparisons
7. Ranking - min_rank(), row_number(), dense_rank(), percent_rank(), cume_dist(),

```{r}
library(dplyr)
library(nycflights13)
not_cancelled <- flights %>%
filter(!is.na(dep_delay), !is.na(arr_delay))
not_cancelled
not_cancelled %>%
group_by(year, month, day) %>%
summarize(mean = mean(dep_delay))
```

3.7 Grouped Summaries with summarize()
This verb is not particularly useful unless paired with group_by()

```{r}
by_day <- group_by(flights, year, month, day)
summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

3.8 Combining Multiple Operations with the Pipe
Example: explore relationship between distance and arrival delay
There are three steps to prepare this data:
1. Group flights by destination.
2. Summarize to compute distance, average delay, and number of flights.
3. Filter to remove noisy points and Honolulu airport, which is almost twice as far away as the next closest airport.
```{r}
by_dest <- group_by(flights, dest)
delay <- summarize(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")
# It looks like delays increase with distance up to ~750 miles
# and then decrease. Maybe as flights get longer there's more
# ability to make up delays in the air?
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
#> `geom_smooth()` using method = 'loess'
```

logic of pipe: x %>% f(y) turns into f(x, y), and x %>% f(y) %>% g(z) turns into g(f(x, y), z)
```{r}
delays <- flights %>%
group_by(dest) %>%
summarize(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %>%
filter(count > 20, dest != "HNL")
```
All aggregation functions have an na.rm argument, whcih removes the missing values prior to computation - add na.rm = TRUE to the argument when summarizing dataframe
```{r}
flights %>%
group_by(year, month, day) %>%
summarize(mean = mean(dep_delay))
flights %>%
group_by(year, month, day) %>%
summarize(mean = mean(dep_delay, na.rm = TRUE))

```

```{r}
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarize(
delay = mean(arr_delay, na.rm = TRUE),
n = n()
)
ggplot(data = delays, mapping = aes(x = n, y = delay)) +
geom_point(alpha = 1/10)
```
Not surprisingly, there is much greater variation in the average delay when there are few flights. The shape of this plot is very characteristic: whenever you plot a mean (or other summary) versus group size, you’ll see that the variation decreases as the sample size increases.

```{r}
delays %>%
filter(n > 25) %>%
ggplot(mapping = aes(x = n, y = delay)) +
geom_point(alpha = 1/10)
```
#Useful Summary Functions
1. Measures of location - median()
2. Measures of spread sd(x), IQR(x), mad(x) - median absolute deviation()
3. Measures of rank min(x), quantile(x, 0.25), max(x)  
4. Measures of position first(x), nth(x, 2), last(x) *why are measures of position complimentary to filtering on ranks?*
```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r = min_rank(desc(dep_time))) %>%
  filter(r %in% range(r))%>% #didn't understand this line
  select(year, month, day, r, everything())
```

5. Counts - 
To count the number of non-missing values, use sum(!is.na(x)). 
To count the number of distinct (unique) values, use n_distinct(x):
```{r}
not_cancelled %>%
group_by(dest) %>%
summarize(carriers = n_distinct(carrier)) %>%
arrange(desc(carriers))
```

6. Counts and proportions of logical values sum(x > 10), mean(y == 0); sum shows the total number of TRUEs in x, whereas mean gives the proportion of TRUEs
```{r}
# How many flights left before 5am? (these usually
# indicate delayed flights from the previous day)
not_cancelled %>%
group_by(year, month, day) %>%
summarize(n_early = sum(dep_time < 500))
```

3.9 Grouping by Multiple Variables 
1. each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset
2. Be careful when progressively rolling up summaries: it’s OK for sums and counts, but you need to think about weighting means and variances, and it’s not possible to do it exactly for rank-based statistics like the median. *how to weight the means and variance when grouping by multiple variables?*

3.10 Grouped Mutates and Filters
Example 1: Find the worst member in the group:
```{r}
flights_sml %>%
group_by(year, month, day) %>%
filter(rank(desc(arr_delay)) < 10)
```
Example 2: Find all groups bigger than a threshold and standardize to compute per group metrics
```{r}
popular_dests <- flights %>%
group_by(dest) %>%
filter(n() > 365)
popular_dests
popular_dests %>%
filter(arr_delay > 0) %>%
mutate(prop_delay = arr_delay / sum(arr_delay)) %>%
select(year:day, dest, arr_delay, prop_delay)
```


When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

